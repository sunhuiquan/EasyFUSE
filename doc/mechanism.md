# 用户态、并发支持、日志恢复机制

1. 用户态：

    设计 FS 的时候，为了显得不那么玩具，我想要通过 linux VFS 接口，但是直接在 linux 内核中实现一个文件系统实在太过困难，所以我选择了通过 libfuse 来实现一个用户态的文件系统.

    简而言之，它作为一个中间层，把内核对 VFS 接口的使用从内核态转发到用户态的我们实现的用户文件系统机制，然后用户文件系统把结果再通过 libfuse 发回内核，来完成对抽象文件系统(VFS)的实现。

    ![IMG](../resource/libfuse_work.png)

    另外 libfuse 本身是作为系统线程运行，通过多线程来实现并发服务的。

2. 并发支持

   1. 首先是inode layer的锁机制，对于 icache 整个缓存区整体、和缓存区内的每一个inode元素都分别拥有一个锁，建立两层锁机制。第一层锁是对于inode cache整体有一个锁保证了一个 inode 在缓存只有一个副本，以及缓存 inode 的引用计数正确；第二层锁是对每个内存中的 inode 都有一个锁，保证了可以独占访问 inode 的相关字段，以及 inode 所对应的数据块。
   2. 再是对data block layer的锁机制，同样是两层锁机制，原理和inode layer锁机制原理一样。
   3. 然后是inode layer缓冲区和data block layer的缓冲区的每一个内存元素都有自己的引用计数ref，用于对内存缓存区的释放和复用。
   4. logging layer使用pthread mutex互斥锁，保证原子性的情况下，使用pthread cond条件变量避免轮询加解锁判断条件，提高性能。
   5. 避免死锁，注意我们内部的通过path查找inode的两个函数 find_dir_inode() 和 find_path_inode()，内部都是按照从根路径向末尾加锁的顺序来对每一级的目录的inode加锁，按照这个顺序，我们可以保证并发查找inode的时候不会发生死锁。

3. 日志机制

   1. 写文件系统调用需要写入磁盘（或其他外存设备或者网络存储）上的内容，会改变外存存储的元数据和普通数据，而在软件崩溃（如OS内核崩溃）或者硬件崩溃（如断电）很有可能造成存储的元数据和普通数据的不一致问题，日志恢复的核心工作就是处理这一个数据不一致的问题，避免导致严重错误。
   2. 写文件系统调用使用 in_transaction( )和 out_transaction() 进出事务，注意并不是一个写系统调用一个事务，而是一个事务里面可以包含多个写系统调用，采用这种批处理的方式，目的是提高性能，当之后当日志块容量不足或者目前无写系统调用被调用的时候，一起提交写入日志，然后根据之前写入磁盘头日志块的映射关系，把内存中的缓存块写入磁盘普通日志块，然后再把磁盘日志块内容写入磁盘数据块，完成事务提交。
   3. 日志恢复本身的原理 to do
   ![IMG](../resource/log_work.png)