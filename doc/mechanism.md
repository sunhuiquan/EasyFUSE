# 用户态、并发支持、日志恢复机制

   1. 再是对data block layer的锁机制，同样是两层锁机制，原理和inode layer锁机制原理一样。
   2. 然后是inode layer缓冲区和data block layer的缓冲区的每一个内存元素都有自己的引用计数ref，用于对内存缓存区的释放和复用。
   3. logging layer使用pthread mutex互斥锁，保证原子性的情况下，使用pthread cond条件变量避免轮询加解锁判断条件，提高性能。
   4. 避免死锁，注意我们内部的通过path查找inode的两个函数 find_dir_inode() 和 find_path_inode()，内部都是按照从根路径向末尾加锁的顺序来对每一级的目录的inode加锁，按照这个顺序，我们可以保证并发查找inode的时候不会发生死锁。

1. 日志机制

   1. 写文件系统调用需要写入磁盘（或其他外存设备或者网络存储）上的内容，会改变外存存储的元数据和普通数据，而在软件崩溃（如OS内核崩溃）或者硬件崩溃（如断电）很有可能造成存储的元数据和普通数据的不一致问题，日志恢复的核心工作就是处理这一个数据不一致的问题，避免导致严重错误。
   2. 写文件系统调用使用 in_transaction( )和 out_transaction() 进出事务，注意并不是一个写系统调用一个事务，而是一个事务里面可以包含多个写系统调用，采用这种批处理的方式，目的是提高性能，当之后当日志块容量不足或者目前无写系统调用被调用的时候，一起提交写入日志，然后根据之前写入磁盘头日志块的映射关系，把内存中的缓存块写入磁盘普通日志块，然后再把磁盘日志块内容写入磁盘数据块，完成事务提交。
   3. 日志恢复本身的原理 to do
   ![IMG](../resource/log_work.png)