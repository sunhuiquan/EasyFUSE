# 项目实现的一些细琐内容

1. 我们使用的是 libfuse high-level API，因为相对简单，但是由于这个原因导致了从 Open file handle(打开文件描述) 到 Inode 中间又多了一层路径名的映射，需要每次再把传给 libfuse 接口实现的实参中的路径名再通过 find_path_inode() 或 find_dir_inode() 调用根据路径名找到对应的 Inode，造成了一些性能浪费，所以我们之后可能会重构，改用 libfuse low-level API。

2. 多文件系统下 libfuse 传递的路径实参问题：
Linux 如果有多个文件系统，那么首先每个文件系统都有自己的根目录，它们内部的实现的路径的/都是代表这个文件系统自己本身的根目录。  
举一个例子，比如一个文件系统B挂载到另一个文件系统A内部，从A的角度上看B的根目录，这个路径是一个例如/dir/dir/mount_B这样的；但具体使用B内部的路径的时候时，文件系统B的挂载路径在B自己眼里是根目录/，文件系统B看不到上一层A的，这个A文件系统看起来的/dir/dir/mount_B路径，在B文件系统的视角就是根目录/，文件系统B看不到挂载的上一层文件系统A的那些路径。  
同理发起关于文件系统的调用，如果对于这个文件系统，那么都以他自己的根目录/为基准的；就是说如果是对挂载 FUSE 的路径发起文件系统调用的时候，libfuse 传递给 EasyFUSE 接口的实参中的路径是从 FUSE 根目录为基础开始的，即是一个把挂载路径当成根目录，后面跟着是相对这个根目录的路径。
知道了这个，我们就可以简单的把 libfuse 传递给我们 EasyFUSE 实参中的的路径简单看作从根目录/开始，而不用考虑挂载所在的上一层别的文件系统(如果有的话)的路径的问题了。

3. 错误处理问题：
函数运行出错，在非致命的情况下一般要把之前获取的锁和其他资源释放以及把对临界区资源修改的操作撤回，来保证共享数据结构和各种资源的一致性，避免在之后造成数据丢失、数据错误、对应关系混乱等数据不一致的错误，也避免死锁、内存泄漏等问题，之后返回一个错误码，继续执行即可。
但有些调用内部实现，需要对多个资源加锁，并多次改变全局数据结构，如果再这之后出错，这里把更改过的全局数据结构恢复到更改前内容（这是为了数据一致性）相对困难，而且正常使用的情况下不应该出现这种错误，所以这种情况下我们调用 panic（util.c）直接报错然后终止程序即可。  
不过如果错误处理不是这么繁杂，还是应该认真应该把获取的资源释放，把更改过的全局数据结构恢复到更改前内容，然后返回错误码，继续执行的。
