# 使用libfuse遇到的一些细节

1. 我们使用的是 libfuse high-level API，因为相对简单，但是由于这个原因导致了从 open file handle 到 libfuse 接口中间又多了一层关于路径名的映射，而且每次还要把路径名再次通过 find_path_inode 或 find_dir_inode 函数再转换到inode，造成性能浪费，所以我们之后可能会重构，改用 libfuse low-level API。

2. 我们将通过linux的文件读写API来模拟磁盘驱动的读写，另外我们为了简单起见，我们FS系统中使用的逻辑块与我们的磁盘驱动程序（也就是我们通过linux文件读写调用模拟的代码）使用的物理块是一对一的关系，这样就大大简化了我们的驱动代码处理逻辑块与物理块映射的逻辑。

3. libfuse的高层API提供了一层打开文件描述和路径名的映射，使得高层API始终使用路径名作为参数。  
这样比如write(fd,...)，fd指向打开描述，打开描述指向Inode号，如果是low level API，我们会传递给libfuse低级API接口的就是这个Inode号；但如果是传递给高层接口，那么内部的那层抽象会把打开描述指向的映射到路径名，使得传递的始终是路径名。  
另外要注意的是，文件描述符和打开文件描述是进程属性，这里和libfuse无关，linux的那些系统调用会处理文件描述符和打开描述的数据结构，而libfuse的接口是从这里再往后面走，直接与Inode关联(低级接口)，或是提供一层映射始终使用路径名(高级接口)。

4. 要明白Linux如果有多个文件系统，那么首先每个文件系统都有自己的根目录，它们内部的实现的路径的/都是代表这个文件系统自己本身的根目录。一个文件系统B挂载到另一个文件系统A上，从A的角度上看B的根目录，这个路径是一个例如/dir/dir/mount_B这样的；但具体使用B内部的路径的时候时，B的挂载路径在B自己眼里是/的，B看不到上一层A的，这个A文件系统看起来的/dir/dir/mount_B路径，在B文件系统的视角就是/，看不到上一次A的那些路径。  
同理，要明白libfuse库挂载到一个路径下(比如linux原来的一个ext4文件系统的一个路径下)，发起关于文件系统的调用，如果是ext4文件系统，那么以他自己的/为基准；如果是对fuse文件系统发起系统调用的时候，传递给接口的path参数的路径是fuse文件系统自己的视角，意思是说比如在ext4眼里挂载路径是一个/a/b/c，挂载目录是c，但在我们实现的fuse眼里，libfuse接口传递的参数就是/，这个/代表的就是挂载目录(ext4看起来是/a/b/c在libfuse接口的参数是/)。  
知道了这个，我们就可以简单的把我们fuse文件系统的路径看作从/开始，而不用关上一层别的文件系统的路径视角了。

5. 错误处理：由于有些调用内部实现，需要对多个资源加锁，并多次改变全局数据结构，如果再这之后出错，虽然这里仍然可以处理，把获取的资源释放，把更改过的全局数据结构恢复到更改前内容（这是为了数据一致性），然后返回错误码；  
但是一些地方的处理太过繁杂，而且正常使用的情况下不应该出现这种错误，所以这种情况下我们直接panic（util.c）直接报错然后终止程序不处理此处的错误；  
不过如果错误处理不是这么繁杂，应该把获取的资源释放，把更改过的全局数据结构恢复到更改前内容，然后返回错误码，程序继续执行。
